#Needs fastaGetGaps.jar, bedtools, seqtk, minimap2, parallel and PBJelly
#fastaGetGaps.jar can be obtained here: https://github.com/VGP/vgp-assembly/blob/master/pipeline/stats/fastaGetGaps.jar
#Probably will generalize this usecase. Requires a fofn of reads. Can be generated by cd-ing to the directory and doing ls $PWD/*.fasta > list.fofn

#1. Get the gaps
java -jar fastaGetGaps.jar genome.fasta gaps_to_fill.bed

#2. flanks the generated bed by 1kb on each side
awk -F'\t' '{print $1"\t"$2-1000"\t"$3+1000}' gaps_to_fill.bed > 1000_flank.bed

#3. map using minimap2 parallely
for i in $(cat list.fofn); do echo "minimap2 -xmap-pb -t 48 to_fill.fasta $i | gzip -c - > data/$i.paf.gz"; done | parallel -j4 &

#4. create a 6 columnar bed. The if statement is to adjust the genome coordinates to create a bed file with a rising orientation
zcat *.paf.gz | awk '{if($NF<$(NF-1)) print $6"\t"$7"\t"$8"\t"$1"\t"$3"\t"$4; else if($(NF-1)<$NF) print $6"\t"$8"\t"$7"\t"$1"\t"$3"\t"$4}' > aligned.bed &

#5. intersect the gaps_to_fill.bed with a 10% reciprocal window overlap so that the reads span the flanks and N's. Fast sort using locale
intersectBed -a to_fill.bed -b aligned.bed -wao -f 0.1 -r | awk '{print $7}' | LC_ALL=C sort -Vk1 --parallel 48 -S 60% -T tmp | awk '!arr[$1]++' > reads.heads
mkdir gapfill
for i in $(cat list.fofn); do echo "seqtk subseq "$i" data/reads.heads | seqtk seq -F ! > gapfill/$(basename "$i" .fasta).gapfill.fastq"; done | parallel -j4 &

#6. Run PBJelly using the files in gapfill
